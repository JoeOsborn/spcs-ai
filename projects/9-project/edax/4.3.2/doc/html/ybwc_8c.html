<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>ybwc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ybwc.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parallel search.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ybwc_8h_source.html">ybwc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="move_8h_source.html">move.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="options_8h_source.html">options.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="search_8h_source.html">search.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="stats_8h_source.html">stats.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="settings_8h_source.html">settings.h</a>&quot;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad4a0c85671094fb20a59df4aed9202b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#ad4a0c85671094fb20a59df4aed9202b5">node_init</a> (<a class="el" href="structNode.html">Node</a> *node, <a class="el" href="structSearch.html">Search</a> *search, const int alpha, const int beta, const int depth, const int n_moves, <a class="el" href="structNode.html">Node</a> *parent)</td></tr>
<tr class="memdesc:ad4a0c85671094fb20a59df4aed9202b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a node.  <a href="#ad4a0c85671094fb20a59df4aed9202b5">More...</a><br/></td></tr>
<tr class="separator:ad4a0c85671094fb20a59df4aed9202b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9158549a90b34b758a3371f60e93a65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a9158549a90b34b758a3371f60e93a65b">node_free</a> (<a class="el" href="structNode.html">Node</a> *node)</td></tr>
<tr class="memdesc:a9158549a90b34b758a3371f60e93a65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free Resources allocated by a node.  <a href="#a9158549a90b34b758a3371f60e93a65b">More...</a><br/></td></tr>
<tr class="separator:a9158549a90b34b758a3371f60e93a65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af882b1bf581c1a2afc29dd8624478421"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#af882b1bf581c1a2afc29dd8624478421">get_helper</a> (<a class="el" href="structNode.html">Node</a> *master, <a class="el" href="structNode.html">Node</a> *node, <a class="el" href="structMove.html">Move</a> *move)</td></tr>
<tr class="memdesc:af882b1bf581c1a2afc29dd8624478421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek for &amp; use an helper node.  <a href="#af882b1bf581c1a2afc29dd8624478421">More...</a><br/></td></tr>
<tr class="separator:af882b1bf581c1a2afc29dd8624478421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dba05be5b187eb162b9311c91e22b38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a7dba05be5b187eb162b9311c91e22b38">node_split</a> (<a class="el" href="structNode.html">Node</a> *node, <a class="el" href="structMove.html">Move</a> *move)</td></tr>
<tr class="memdesc:a7dba05be5b187eb162b9311c91e22b38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structNode.html">Node</a> split.  <a href="#a7dba05be5b187eb162b9311c91e22b38">More...</a><br/></td></tr>
<tr class="separator:a7dba05be5b187eb162b9311c91e22b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cab65bf7dade2f8653a2e3276b89c78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a6cab65bf7dade2f8653a2e3276b89c78">node_wait_slaves</a> (<a class="el" href="structNode.html">Node</a> *node)</td></tr>
<tr class="memdesc:a6cab65bf7dade2f8653a2e3276b89c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for slaves termination.  <a href="#a6cab65bf7dade2f8653a2e3276b89c78">More...</a><br/></td></tr>
<tr class="separator:a6cab65bf7dade2f8653a2e3276b89c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3720f7191596fadf637ee6fddc8666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#aaa3720f7191596fadf637ee6fddc8666">node_update</a> (<a class="el" href="structNode.html">Node</a> *node, <a class="el" href="structMove.html">Move</a> *move)</td></tr>
<tr class="memdesc:aaa3720f7191596fadf637ee6fddc8666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a node.  <a href="#aaa3720f7191596fadf637ee6fddc8666">More...</a><br/></td></tr>
<tr class="separator:aaa3720f7191596fadf637ee6fddc8666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2247a628b88fd27119dfbe49a41111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMove.html">Move</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#add2247a628b88fd27119dfbe49a41111">node_first_move</a> (<a class="el" href="structNode.html">Node</a> *node, <a class="el" href="structMoveList.html">MoveList</a> *movelist)</td></tr>
<tr class="memdesc:add2247a628b88fd27119dfbe49a41111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first move of the move list.  <a href="#add2247a628b88fd27119dfbe49a41111">More...</a><br/></td></tr>
<tr class="separator:add2247a628b88fd27119dfbe49a41111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e58a0825e315ec77c2504f4f3f1fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structMove.html">Move</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#afa0e58a0825e315ec77c2504f4f3f1fe">node_next_move_lockless</a> (<a class="el" href="structNode.html">Node</a> *node)</td></tr>
<tr class="memdesc:afa0e58a0825e315ec77c2504f4f3f1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next move of the move list.  <a href="#afa0e58a0825e315ec77c2504f4f3f1fe">More...</a><br/></td></tr>
<tr class="separator:afa0e58a0825e315ec77c2504f4f3f1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744689fe7920707e9cf5a4149be74b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMove.html">Move</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a744689fe7920707e9cf5a4149be74b46">node_next_move</a> (<a class="el" href="structNode.html">Node</a> *node)</td></tr>
<tr class="memdesc:a744689fe7920707e9cf5a4149be74b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next move of the move list.  <a href="#a744689fe7920707e9cf5a4149be74b46">More...</a><br/></td></tr>
<tr class="separator:a744689fe7920707e9cf5a4149be74b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4fc1461e78cd5569318f9e19399e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#aaa4fc1461e78cd5569318f9e19399e50">task_search</a> (<a class="el" href="structTask.html">Task</a> *task)</td></tr>
<tr class="memdesc:aaa4fc1461e78cd5569318f9e19399e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel search within a <a class="el" href="structTask.html">Task</a> structure.  <a href="#aaa4fc1461e78cd5569318f9e19399e50">More...</a><br/></td></tr>
<tr class="separator:aaa4fc1461e78cd5569318f9e19399e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b16943d9461c507b37a3228768e840d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a6b16943d9461c507b37a3228768e840d">task_loop</a> (void *param)</td></tr>
<tr class="memdesc:a6b16943d9461c507b37a3228768e840d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main loop runned by a task.  <a href="#a6b16943d9461c507b37a3228768e840d">More...</a><br/></td></tr>
<tr class="separator:a6b16943d9461c507b37a3228768e840d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b9a17df0c2e4680a301bf4a854b3f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSearch.html">Search</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a45b9a17df0c2e4680a301bf4a854b3f6">task_search_create</a> (<a class="el" href="structTask.html">Task</a> *task)</td></tr>
<tr class="memdesc:a45b9a17df0c2e4680a301bf4a854b3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a search structure for a task.  <a href="#a45b9a17df0c2e4680a301bf4a854b3f6">More...</a><br/></td></tr>
<tr class="separator:a45b9a17df0c2e4680a301bf4a854b3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7bd64f0f200af48220e3dc4fc4c168"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#aeb7bd64f0f200af48220e3dc4fc4c168">task_search_destroy</a> (<a class="el" href="structSearch.html">Search</a> *search)</td></tr>
<tr class="memdesc:aeb7bd64f0f200af48220e3dc4fc4c168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a search structure of a task.  <a href="#aeb7bd64f0f200af48220e3dc4fc4c168">More...</a><br/></td></tr>
<tr class="separator:aeb7bd64f0f200af48220e3dc4fc4c168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638ff15b10d60e8dde5b78cf7d32f4cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a638ff15b10d60e8dde5b78cf7d32f4cb">task_init</a> (<a class="el" href="structTask.html">Task</a> *task)</td></tr>
<tr class="memdesc:a638ff15b10d60e8dde5b78cf7d32f4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a task.  <a href="#a638ff15b10d60e8dde5b78cf7d32f4cb">More...</a><br/></td></tr>
<tr class="separator:a638ff15b10d60e8dde5b78cf7d32f4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac944c5b45b2c8870c2eea4d4a140bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a7ac944c5b45b2c8870c2eea4d4a140bb">task_free</a> (<a class="el" href="structTask.html">Task</a> *task)</td></tr>
<tr class="memdesc:a7ac944c5b45b2c8870c2eea4d4a140bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources used by a task.  <a href="#a7ac944c5b45b2c8870c2eea4d4a140bb">More...</a><br/></td></tr>
<tr class="separator:a7ac944c5b45b2c8870c2eea4d4a140bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb14f779a1d8a9e62b7f7acdbd0eebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a9cb14f779a1d8a9e62b7f7acdbd0eebe">task_stack_init</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *stack, const int n)</td></tr>
<tr class="memdesc:a9cb14f779a1d8a9e62b7f7acdbd0eebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the stack of tasks.  <a href="#a9cb14f779a1d8a9e62b7f7acdbd0eebe">More...</a><br/></td></tr>
<tr class="separator:a9cb14f779a1d8a9e62b7f7acdbd0eebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d09308199e359679ee70d35346b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a014d09308199e359679ee70d35346b97">task_stack_free</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *stack)</td></tr>
<tr class="memdesc:a014d09308199e359679ee70d35346b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources used by the stack of tasks.  <a href="#a014d09308199e359679ee70d35346b97">More...</a><br/></td></tr>
<tr class="separator:a014d09308199e359679ee70d35346b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a724079314f7b0fa62a0d83ad74541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a95a724079314f7b0fa62a0d83ad74541">task_stack_resize</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *stack, const int n)</td></tr>
<tr class="memdesc:a95a724079314f7b0fa62a0d83ad74541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources used by the stack of tasks.  <a href="#a95a724079314f7b0fa62a0d83ad74541">More...</a><br/></td></tr>
<tr class="separator:a95a724079314f7b0fa62a0d83ad74541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11f7bb4a76bc871550c8be50abdaf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTask.html">Task</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a8d11f7bb4a76bc871550c8be50abdaf8">task_stack_get_idle_task</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *stack)</td></tr>
<tr class="memdesc:a8d11f7bb4a76bc871550c8be50abdaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, if available, an idle task.  <a href="#a8d11f7bb4a76bc871550c8be50abdaf8">More...</a><br/></td></tr>
<tr class="separator:a8d11f7bb4a76bc871550c8be50abdaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541d0a660f555b33a2124d1131b2eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#ac541d0a660f555b33a2124d1131b2eb0">task_stack_put_idle_task</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *stack, <a class="el" href="structTask.html">Task</a> *task)</td></tr>
<tr class="memdesc:ac541d0a660f555b33a2124d1131b2eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back an idle task after using it.  <a href="#ac541d0a660f555b33a2124d1131b2eb0">More...</a><br/></td></tr>
<tr class="separator:ac541d0a660f555b33a2124d1131b2eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6aeb656c0448d0b7ba6f12d981618620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLog.html">Log</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8c.html#a6aeb656c0448d0b7ba6f12d981618620">search_log</a> [1]</td></tr>
<tr class="separator:a6aeb656c0448d0b7ba6f12d981618620"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parallel search. </p>
<p>The Young Brother Wait Concept [1, 2] is an efficient technique to search a position with several cpu/core working in parallel. At an inner nodes, this technique always evaluates the first move using a sequential approach, but try to evaluate the siblings in parallel, once the first move has been computed. The YBWC has some nice properties: low search overhead, good scalability, easy implementation, etc.</p>
<p>This file holds the function definition to manipulate structures used in our implementation of parallelism:</p>
<ul>
<li><a class="el" href="structNode.html">Node</a> describes a position shared between different threads.</li>
<li><a class="el" href="structTask.html">Task</a> describes a search running in parallel within a thread.</li>
<li><a class="el" href="structTaskStack.html">TaskStack</a> is a FIFO providing task available for a new search.</li>
</ul>
<p>References:</p>
<ol type="1">
<li>Feldmann R., Monien B., Mysliwietz P. Vornberger O. (1989) Distributed Game-Tree <a class="el" href="structSearch.html">Search</a>. ICCA Journal, Vol. 12, No. 2, pp. 65-73.</li>
<li>Feldmann R. (1993) Game-Tree <a class="el" href="structSearch.html">Search</a> on Massively Parallel System - PhD Thesis, Paderborn (English version).</li>
</ol>
<dl class="section date"><dt>Date</dt><dd>1998 - 2012 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Richard Delorme </dd></dl>
<dl class="section version"><dt>Version</dt><dd>4.3 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af882b1bf581c1a2afc29dd8624478421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool get_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMove.html">Move</a> *&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek for &amp; use an helper node. </p>
<p>When asking for an idle task, this function look if a parent node is waiting and has a task available to help the current search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master</td><td>A parent node with an idle task. </td></tr>
    <tr><td class="paramname">node</td><td>Searched node. </td></tr>
    <tr><td class="paramname">move</td><td>Searched move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an helper task has been launch, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="add2247a628b88fd27119dfbe49a41111"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMove.html">Move</a>* node_first_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMoveList.html">MoveList</a> *&#160;</td>
          <td class="paramname"><em>movelist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first move of the move list. </p>
<p>This is thread/safe getter of the first move. If the search is stopped, or an alphabeta cut has been found or no move is available the function returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a> data. </td></tr>
    <tr><td class="paramname">movelist</td><td>List of moves. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first move of the list or NULL if none is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a9158549a90b34b758a3371f60e93a65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free Resources allocated by a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4a0c85671094fb20a59df4aed9202b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSearch.html">Search</a> *&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_moves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a node. </p>
<p>Initialize the various members of the node structure. The important part of the initialization establishes a master-slave relashionship between this node (the slave) and its parent (the master).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A potentially shared position. </td></tr>
    <tr><td class="paramname">search</td><td>The position searched </td></tr>
    <tr><td class="paramname">alpha</td><td>lower score bound. </td></tr>
    <tr><td class="paramname">beta</td><td>upper score bound. </td></tr>
    <tr><td class="paramname">depth</td><td>depth. </td></tr>
    <tr><td class="paramname">n_moves</td><td><a class="el" href="structMove.html">Move</a> count. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a744689fe7920707e9cf5a4149be74b46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMove.html">Move</a>* node_next_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next move of the move list. </p>
<p>This is a thread/safe getter of the next move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a> data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next move of the list. </dd></dl>

</div>
</div>
<a class="anchor" id="afa0e58a0825e315ec77c2504f4f3f1fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structMove.html">Move</a>* node_next_move_lockless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next move of the move list. </p>
<p>This is a thread/safe getter of the next move. If the search is stopped, or an alphabeta cut has been found or no move is available the function returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a> data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next move of the list or NULL if none is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dba05be5b187eb162b9311c91e22b38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool node_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMove.html">Move</a> *&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structNode.html">Node</a> split. </p>
<p>Here is the heart of the YBWC algorithm. It splits a node into two tasks. Splitting occurs if the following conditions are met:</p>
<ol type="1">
<li><b> the first move has been already searched</b>. The main principle of the YBWC algorithm. It avoids to split a cut-type node, for which searching a single move is enough, and thus diminish search-overhead.</li>
<li>search to do is deep enough. In order to diminish the overhead of the parallelism. Can be tuned through SPLIT_MIN_DEPTH.</li>
<li>the node has not been splitted yet. For a single position, only two tasks can run in parallel. The idea is to favor splitting elsewhere in the tree.</li>
<li>This is not the last move. The idea is to lose less time in waiting for the parallel task to terminate. Can be tuned through SPLIT_MIN_MOVES_TODO. If these conditions are met, an idle task is requested, first from an idle task of a parent node; then, if none is available, from the idle task stack storage. If no idle task is found, the node splitting fails.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Master node to split. </td></tr>
    <tr><td class="paramname">move</td><td>move to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the split was a success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3720f7191596fadf637ee6fddc8666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMove.html">Move</a> *&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a node. </p>
<p>Update bestmove, bestscore and alpha value of the node, in case the move is the bestmove found so far. The function is thread-safe although it updates a shared resource. Double check lock is used as an optimization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>current node. </td></tr>
    <tr><td class="paramname">move</td><td>last evaluated move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cab65bf7dade2f8653a2e3276b89c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_wait_slaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for slaves termination. </p>
<p>Actually, three steps are performed here:</p>
<ol type="1">
<li>Stop slaves node in case their scores are unneeded.</li>
<li>Wait for slaves' termination.</li>
<li>Wake-up the master thread that may have been stopped.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ac944c5b45b2c8870c2eea4d4a140bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources used by a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a638ff15b10d60e8dde5b78cf7d32f4cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a task. </p>
<p>Initialize task data members and start the task main loop <a class="el" href="ybwc_8c.html#a6b16943d9461c507b37a3228768e840d" title="The main loop runned by a task.">task_loop()</a> within a thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b16943d9461c507b37a3228768e840d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* task_loop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main loop runned by a task. </p>
<p>When task-&gt;run is set to true, the task starts a parallel search. In order to diminish the parallelism overhead, we do not launch a new thread at each new splitted node. Instead the threads are created at the beginning of the program and run a waiting loop who enters/quits a parallel search when requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa4fc1461e78cd5569318f9e19399e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parallel search within a <a class="el" href="structTask.html">Task</a> structure. </p>
<p>Here we share the search with a main parent task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to search with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45b9a17df0c2e4680a301bf4a854b3f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSearch.html">Search</a>* task_search_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a search structure for a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a search structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb7bd64f0f200af48220e3dc4fc4c168"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void task_search_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSearch.html">Search</a> *&#160;</td>
          <td class="paramname"><em>search</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a search structure of a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search</td><td>The search structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a014d09308199e359679ee70d35346b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources used by the stack of tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d11f7bb4a76bc871550c8be50abdaf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTask.html">Task</a>* task_stack_get_idle_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return, if available, an idle task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An idle task. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cb14f779a1d8a9e62b7f7acdbd0eebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the stack of tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
    <tr><td class="paramname">n</td><td>Stack size (number of tasks). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac541d0a660f555b33a2124d1131b2eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_put_idle_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put back an idle task after using it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
    <tr><td class="paramname">task</td><td>An idle task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95a724079314f7b0fa62a0d83ad74541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources used by the stack of tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Stack to resize. </td></tr>
    <tr><td class="paramname">n</td><td>New stack size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a6aeb656c0448d0b7ba6f12d981618620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLog.html">Log</a> search_log[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
